---
layout: post
title: "Mysql事务概念总结"
subtitle: '浅谈Mysql事务'
author: "Jim"
header-style: text
lang: cn
tags:
  - 事务
  - Mysql
  - 笔记
---

### 事物 
事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。在关系数据库中，一个事务可以是一组SQL语句或整个程序。

### 为什么要有事物
一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：
1. 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库在异常状态下仍能保持一致性的方法。
2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，保证彼此的操作互相干扰。

### 事物特性  
事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

- 原子性（atomicity）：
  一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。
  原子性关注状态，不存在部分成功的状态。
- 一致性（consistency）：
  事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。一致性关注的
    是数据的可见性，中间状态对外不可见，只有最初状态和最终状态数据对外可见
- 隔离性（isolation）：
  一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事物未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。
- 持久性（durability）：
  一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

### 数据库并发事物中存在的问题
如果不考虑事务的隔离性，会发生以下几种问题：
- 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。
- 不可重复读：不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值(这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，该事物需要用到的数据被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。需要注意的是在某些情况下不可重复读并不是问题。
- 幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。

### 事物的隔离级别
在事物中存在以下几种隔离级别：
- 读未提交(Read Uncommitted)：解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。
- 读已提交(Read Committed)：解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事物结束。
- 可重复读取(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事物结束后再释放。
- 串行化(Serializable)：解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

### 排他锁，共享锁
排它锁（Exclusive），又称为X 锁，写锁。  
共享锁（Shared），又称为S 锁，读锁。  
读写锁之间有以下的关系：  
- 一个事务对数据对象O加了 S 锁，可以对 O进行读取操作，但是不能进行更新操作。加锁期间其它事务能对O 加 S 锁，但是不能加 X 锁。  
- 一个事务对数据对象 O 加了 X 锁，就可以对 O 进行读取和更新。加锁期间其它事务不能对 O 加任何锁。  
即读写锁之间的关系可以概括为：多读单写

### MySQL InnoDB锁机制之Gap Lock、Next-Key Lock、Record Lock
MySQL InnoDB支持三种行锁定方式：
1. 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。
2. 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。
3. Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock，既锁住了记录也锁住了范围。
3.1 select * from test where id = 8 for update;
3.2 (-∞, 1], (1, 3], (3, 5], (5, 8], (8, 11], (11, +∞)
3.3 执行后除了锁住8所在的范围，还会锁住下一个范围，所谓Next-Key

默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。

### 当前读，快照度，MVVC(多版本并发)
#### 1. 快照读：  
- 简单的select操作(不包括 select ... lock in share mode, select ... for update)。　　　　
- Read Committed隔离级别：每次select都生成一个快照读，每次快照读都是最新的提交的数据，因此也可以看到其他已commit事务的更改。
- Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。因此，只有第一次select之前其他提交的事务的修改可以看到，如果已经执行了select，那么其他事务commit的数据，你select是看不到的。
- 快照读的实现方式：undolog和MVCC  
　　MVCC：多版本并发控制(Multi-Version Concurrency Control, MVCC)是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现读已提交和可重复读取隔离级别的实现。

#### 2. 当前读： 
- select...lock in share mode (共享读锁)   
select...for update  
update , delete , insert

- 当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。  
　　例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。

- 当前读的实现方式：next-key锁(行记录锁+Gap间隙锁)
　　间隙锁：只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及后面的数字都会被锁定，因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。  
    1. 对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。  
    2. 没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。  
    3. 非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。    

### 参考文章：
本文是学习和整理自下列文章：
1. [浅谈MySQL的七种锁](https://yq.aliyun.com/articles/646976)
2. [mysql之锁与事务详解](https://blog.hhui.top/hexblog/2018/03/23/mysql%E4%B9%8B%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/)
3. [互联网项目中mysql应该选什么事务隔离级别](https://yq.aliyun.com/articles/693143)
4. [MySQL的可重复读级别能解决幻读吗](https://www.cnblogs.com/liyus/p/10556563.html)  

如有侵权，请联系我删除相关内容。如有错误，欢迎评论纠正。

